syntax = "proto3";

package com.gradido.proto;

import "BasicTypes.proto";
import "Timestamp.proto";

message SignaturePair {
    bytes pub_key = 1;  
    // TODO: simplify
    oneof signature {
        bytes ed25519 = 2; // ed25519 signature (libsodium default)
		bytes ed25519_ref10 = 3; // ed25519 ref10 signature
    }
}

message SignatureMap {
    repeated SignaturePair sig_pair = 1; // Each signature pair corresponds to a unique Key required to sign the transaction.
}

message Amount {
	bytes pubkey = 1;
	double amount = 2;
}

message LocalTransfer {
    Amount sender = 1;
    bytes receiver = 2;
}

message CrossGroupTransfer {
    Amount sender = 1;
    bytes receiver = 2;
    bytes other_group = 3;
    // this matches related OutboundTransfer.paired_transaction_id
    .proto.Timestamp paired_transaction_id = 4;
}

message GradidoTransfer {
    oneof data {
        LocalTransfer local = 1;
        CrossGroupTransfer inbound = 2;
        CrossGroupTransfer outbound = 3;
    }
}

message GroupFriendsUpdate {
    // char[16], alias
    bytes group = 1;
    
    enum Action {
        ADD_FRIEND=0;
        REMOVE_FRIEND=1;
    };
    Action action = 2;
}

message GroupMemberUpdate {
    bytes user_pubkey = 1;

    enum MemberUpdateType {
        ADD_USER=0;
        MOVE_USER_INBOUND=1;
        MOVE_USER_OUTBOUND=2;
    };
    MemberUpdateType member_update_type = 2;

    // this only makes sense for user move, TODO: probably restructure
    .proto.Timestamp paired_transaction_id = 3;
    bytes target_group = 4;
}

message GradidoCreation {
    Amount receiver = 1; 
}

message DebugResetBlockchainMark {
    bool do_reset = 1;
}

message TransactionBody {
	string memo = 1; // max 150 chars

	oneof data {
        GradidoTransfer transfer = 2;
		GradidoCreation creation = 3;
        GroupFriendsUpdate group_friends_update = 4;
        GroupMemberUpdate group_member_update = 5;
        DebugResetBlockchainMark debug_reset_blockchain_mark = 6;
	}

    uint64 version_number = 7;
}

message GradidoTransaction {
	SignatureMap sig_map = 1;

    // TODO: consider if having concrete type wouldn't be better; 
    // having bytes would better show what is signed, still for 
    // blockchain it doesn't matter, as it has to be serialized again
    // when validating
	bytes body_bytes = 2; // TransactionBody
}

message AddGroupToRegister {
    bytes alias = 1;
    bool reset_group_register = 2;
}

message ManageGroupRequest {
    enum Action {
         ADD_GROUP = 0;
         REMOVE_GROUP = 1;
    }
    Action action = 1;
    bytes group = 2;
}

message ManageGroupResponse {
    bool success = 1;    
}

message BlockRangeDescriptor {
    bytes group = 1;
    uint64 first_record = 2;        
    uint64 record_count = 3;
}

message TransactionPart {
    // 64 bytes
    bytes hash = 1;
    bytes record = 2; // record as it is stored in blockchain
}

message BlockRecord {
    bool success = 1;
    repeated TransactionPart part = 2;
}

message ManageNodeNetwork {
    enum Action {
         ADD_NODE = 0;
         REMOVE_NODE = 1;
    }
    Action action = 1;
    bytes endpoint = 2;
}

message ManageNodeNetworkResponse {
    bool success = 1;
}

service BlockService {
    rpc subscribe_to_blocks (BlockRangeDescriptor) returns (stream BlockRecord);
}

service GradidoNode {
    rpc manage_group (ManageGroupRequest) returns (ManageGroupResponse);
}

service NodeService {
    rpc manage_node_network (ManageNodeNetwork) returns (ManageNodeNetworkResponse);
}
