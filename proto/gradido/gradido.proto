syntax = "proto3";

package com.gradido.proto;

import "BasicTypes.proto";
import "Timestamp.proto";

message SignaturePair {
    bytes pub_key = 1;  
    // TODO: simplify
    oneof signature {
        bytes ed25519 = 2; // ed25519 signature (libsodium default)
		bytes ed25519_ref10 = 3; // ed25519 ref10 signature
    }
}

message SignatureMap {
    repeated SignaturePair sig_pair = 1; // Each signature pair corresponds to a unique Key required to sign the transaction.
}

message Amount {
	bytes pubkey = 1;
	double amount = 2;
}

message LocalTransfer {
    Amount sender = 1;
    bytes receiver = 2;
}

message CrossGroupTransfer {
    Amount sender = 1;
    bytes receiver = 2;
    bytes other_group = 3;
    // this matches related OutboundTransfer.paired_transaction_id
    .proto.Timestamp paired_transaction_id = 4;
}

message GradidoTransfer {
    oneof data {
        LocalTransfer local = 1;
        CrossGroupTransfer inbound = 2;
        CrossGroupTransfer outbound = 3;
    }
}

message GroupFriendsUpdate {
    // char[16], alias
    bytes group = 1;
    
    enum Action {
        ADD_FRIEND=0;
        REMOVE_FRIEND=1;
    };
    Action action = 2;
}

message GroupMemberUpdate {
    bytes user_pubkey = 1;

    enum MemberUpdateType {
        ADD_USER=0;
        MOVE_USER_INBOUND=1;
        MOVE_USER_OUTBOUND=2;
    };
    MemberUpdateType member_update_type = 2;

    // this only makes sense for user move, TODO: probably restructure
    .proto.Timestamp paired_transaction_id = 3;
    bytes target_group = 4;
}

message GradidoCreation {
    Amount receiver = 1; 
}

message DebugResetBlockchainMark {
    bool do_reset = 1;
}

message TransactionBody {
	string memo = 1; // max 150 chars
	uint64 version_number = 2;

	oneof data {
        GradidoTransfer transfer = 3;
		GradidoCreation creation = 4;
        GroupFriendsUpdate group_friends_update = 5;
        GroupMemberUpdate group_member_update = 6;
        DebugResetBlockchainMark debug_reset_blockchain_mark = 7;
	}
}


message GradidoTransaction {
	SignatureMap sig_map = 1;

    // TODO: consider if having concrete type wouldn't be better; 
    // having bytes would better show what is signed, still for 
    // blockchain it doesn't matter, as it has to be serialized again
    // when validating
	// UNICORN ANSWER:
	// Maybe but hedera has at first concrete type and has depracted that now, so is must 
	// be reason for that
	bytes body_bytes = 2; // TransactionBody
}


message AddGroupToRegister {
    bytes alias = 1;
    .proto.TopicID topic_id = 2;
    bool reset_group_register = 3; // for debugging purposes only
}

/*
// copyed from hedera topic id
message HederaID {
    int64 shardNum = 1; // The shard number (nonnegative)
    int64 realmNum = 2; // The realm number (nonnegative)
    int64 topicNum = 3; // Unique topic identifier within a realm (nonnegative).
}

message ManageNodeGroupAdd {
    string   group_name = 1;
	string   group_alias = 2;
	HederaID hedera_topic_id = 3;
	//string parent_group_alias = 4; 
}

message ManageNodeBody {
    uint64 version_number = 1;
	
	oneof data {
        ManageNodeGroupAdd group_add = 3;
	}
}

//	used for controlling node server by login-server
//	same signature strategy like transactions
message ManageNodeRequest {
    SignatureMap sig_map = 1;
	bytes body_bytes = 2; // ManageNodeBody
}

message ManageNodeResponse {
	bool success = 1;
	enum ErrorCode {
		INVALID_BODY = 0;
		INVALID_SIGNATURE = 1;
		SIGNER_NOT_KNOWN = 2;
		GROUP_ALIAS_ALREADY_EXIST = 3;
	}
	ErrorCode error = 2;
}
*/
message ManageGroupRequest {
    enum Action {
         ADD_GROUP = 0;
         REMOVE_GROUP = 1;
    }
    Action action = 1;
    bytes group = 2;
}

message ManageGroupResponse {
    bool success = 1;    
}

message GroupDescriptor {
    bytes group = 1;
}

message BlockDescriptor {
    GroupDescriptor group = 1;
    uint32 block_id = 2;        
}

message BlockRecord {
    bool success = 1;
    bytes record = 2; // record as it is stored in blockchain
}

message BlockChecksum {
    bool success = 1;
    uint32 block_size = 2;
    bytes checksum = 3;
}

message ManageNodeNetwork {
    enum Action {
         ADD_NODE = 0;
         REMOVE_NODE = 1;
    }
    Action action = 1;
    bytes endpoint = 2;
}

message ManageNodeNetworkResponse {
    bool success = 1;
}

message OutboundTransactionDescriptor {
    bytes group = 1;
    .proto.Timestamp paired_transaction_id = 2;
}

// TODO: probably use BlockRecord instead
message OutboundTransaction {
    bool success = 1;
    bytes data = 2;
}

message UserDescriptor {
    bytes group_alias = 1;
    bytes pubkey = 2;
}

message TransactionRangeDescriptor {
    bytes group_alias = 1;
    uint64 start_seq_num = 2;    
}

message TransactionData {
    bool success = 1;
    bytes record = 2;
}

message CreationSumRangeDescriptor {
    UserDescriptor user = 1;
    uint32 month = 2;
    uint32 year = 3;        
}

message CreationSumData {
    bool success = 1;
    uint64 balance = 2;
}

message UserData {
    bool success = 1;
    bytes pubkey = 2;        
}

message UserBalance {
    bool success = 1;
    Amount amount = 2;
}

service GradidoNodeService {
    rpc subscribe_to_blocks (BlockDescriptor) returns (stream BlockRecord);
    rpc subscribe_to_block_checksums (GroupDescriptor) returns (stream BlockChecksum);
    // having stream as response for simplicity; should be non-stream; on
    // the other hand, stream with just one message of success=0 means
    // "no data", which is useful with protobuf
    rpc manage_group (ManageGroupRequest) returns (stream ManageGroupResponse);
    rpc manage_node_network (ManageNodeNetwork) returns (stream ManageNodeNetworkResponse);
    rpc get_outbound_transaction (OutboundTransactionDescriptor) returns (stream OutboundTransaction);

    rpc get_balance (UserDescriptor) returns (stream UserBalance);
    rpc get_transactions (TransactionRangeDescriptor) returns (stream TransactionData);
    rpc get_creation_sum (CreationSumRangeDescriptor) returns (stream CreationSumData);
    rpc get_users (GroupDescriptor) returns (stream UserData);
}
