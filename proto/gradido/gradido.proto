syntax = "proto3";

package com.gradido.proto;

import "BasicTypes.proto";
import "Timestamp.proto";

message SignaturePair {
    bytes pub_key = 1;  
    // TODO: simplify
    oneof signature {
        bytes ed25519 = 2; // ed25519 signature (libsodium default)
		bytes ed25519_ref10 = 3; // ed25519 ref10 signature
    }
}

message SignatureMap {
    repeated SignaturePair sig_pair = 1; // Each signature pair corresponds to a unique Key required to sign the transaction.
}

message Amount {
	bytes pubkey = 1;
	double amount = 2;
}

message LocalTransfer {
    Amount sender = 1;
    bytes receiver = 2;
}

message CrossGroupTransfer {
    Amount sender = 1;
    bytes receiver = 2;
    bytes other_group = 3;
    // this matches related OutboundTransfer.paired_transaction_id
    .proto.Timestamp paired_transaction_id = 4;
}

message GradidoTransfer {
    oneof data {
        LocalTransfer local = 1;
        CrossGroupTransfer inbound = 2;
        CrossGroupTransfer outbound = 3;
    }
}

message GroupFriendsUpdate {
    // char[16], alias
    bytes group = 1;
    
    enum Action {
        ADD_FRIEND=0;
        REMOVE_FRIEND=1;
    };
    Action action = 2;
}

message GroupMemberUpdate {
    bytes user_pubkey = 1;

    enum MemberUpdateType {
        ADD_USER=0;
        MOVE_USER_INBOUND=1;
        MOVE_USER_OUTBOUND=2;
    };
    MemberUpdateType member_update_type = 2;

    // this only makes sense for user move, TODO: probably restructure
    .proto.Timestamp paired_transaction_id = 3;
    bytes target_group = 4;
}

message GradidoCreation {
    Amount receiver = 1; 
}

message TransactionBody {
	string memo = 1; // max 150 chars
	uint64 version_number = 2;

	oneof data {
        GradidoTransfer transfer = 3;
		GradidoCreation creation = 4;
        GroupFriendsUpdate group_friends_update = 5;
        GroupMemberUpdate group_member_update = 6;
	} 
}


message GradidoTransaction {
	SignatureMap sig_map = 1;

    // TODO: consider if having concrete type wouldn't be better; 
    // having bytes would better show what is signed, still for 
    // blockchain it doesn't matter, as it has to be serialized again
    // when validating
	// UNICORN ANSWER:
	// Maybe but hedera has at first concrete type and has depracted that now, so is must 
	// be reason for that
	bytes body_bytes = 2; // TransactionBody
}

// copyed from hedera topic id
message HederaID {
    int64 shardNum = 1; // The shard number (nonnegative)
    int64 realmNum = 2; // The realm number (nonnegative)
    int64 topicNum = 3; // Unique topic identifier within a realm (nonnegative).
}

message ManageNodeGroupAdd {
    string   group_name = 1;
	string   group_alias = 2;
	HederaID hedera_topic_id = 3;
	//string parent_group_alias = 4; 
}

message ManageNodeBody {
    uint64 version_number = 1;
	
	oneof data {
        ManageNodeGroupAdd group_add = 3;
	}
}
/*
	used for controlling node server by login-server
	same signature strategy like transactions
*/
message ManageNodeRequest {
    SignatureMap sig_map = 1;
	bytes body_bytes = 2; // ManageNodeBody
}

message ManageNodeResponse {
	bool success = 1;
	enum ErrorCode {
		INVALID_BODY = 0;
		INVALID_SIGNATURE = 1;
		SIGNER_NOT_KNOWN = 2;
		GROUP_ALIAS_ALREADY_EXIST = 3;
	}
	ErrorCode error = 2;
}

message ManageGroupRequest {
    enum Action {
         ADD_GROUP = 0;
         REMOVE_GROUP = 1;
    }
    Action action = 1;
    bytes group = 2;
}

message ManageGroupResponse {
    bool success = 1;    
}

message BlockRangeDescriptor {
    bytes group = 1;
    uint64 first_record = 2;        
    uint64 record_count = 3;
}

message TransactionPart {
    // 64 bytes
    bytes hash = 1;
    bytes record = 2; // record as it is stored in blockchain
}

message BlockRecord {
    bool success = 1;
    repeated TransactionPart part = 2;
}

message ManageNodeNetwork {
    enum Action {
         ADD_NODE = 0;
         REMOVE_NODE = 1;
    }
    Action action = 1;
    bytes endpoint = 2;
}

message ManageNodeNetworkResponse {
    bool success = 1;
}

service BlockService {
    rpc subscribe_to_blocks (BlockRangeDescriptor) returns (stream BlockRecord);
}

service GradidoNode {
    rpc manage_group (ManageGroupRequest) returns (ManageGroupResponse);
}

service NodeService {
    rpc manage_node_network (ManageNodeNetwork) returns (ManageNodeNetworkResponse);
}
